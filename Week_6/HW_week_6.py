
# coding: utf-8

# 1. Подсчитать, сколько было выделено памяти под переменные в ранее разработанных
# программах в рамках первых трех уроков. Проанализировать результат и определить
# программы с наиболее эффективным использованием памяти.
# 
# Примечание: Для анализа возьмите любые 1-3 ваших программы или несколько вариантов кода для
# одной и той же задачи. Результаты анализа вставьте в виде комментариев к коду. Также укажите в
# комментариях версию Python и разрядность вашей ОС.

# #### Python v.3.6.5
# #### OS: Windows 10 x64

# In[81]:


""" 
# Установка модуля pympler в Jupiter notebook 

import pip
!{sys.executable} -m pip install pympler
"""

from pympler import asizeof
import sys
import timeit
print(sys.version_info) # Версия ядра python - 3.6.5: sys.version_info(major=3, minor=6, micro=5, releaselevel='final', serial=0)


# In[33]:


###########################################
# Тест на базовых переменных и структурах #
###########################################
a = str(1)
b = int(1)
c = float(1)
d = True

print(f"Размер памяти под str: {asizeof.asizeof(a)}")
print(f"Размер памяти под int: {asizeof.asizeof(b)}")
print(f"Размер памяти под float: {asizeof.asizeof(c)}")
print(f"Размер памяти под bool: {asizeof.asizeof(d)}")
print()

z1 = {1,2,3}
z2 = [1,2,3]
zs2 = ['1', '2','3']
z3 = (1,2,3)
print(f"Размер памяти под словарь из 3-х цифр: {asizeof.asizeof(z1)}")
print(f"Размер памяти под массив из 3-х знаков: {asizeof.asizeof(s)}")
print(f"Размер памяти под массив 3-х цифр: {asizeof.asizeof(z2)}")
print(f"Размер памяти под кортеж 3-х цифр: {asizeof.asizeof(z3)}")


# In[117]:


# Код позаимствован из ДЗ 2-го урока. (В примере использовано 20-значное число)
# В задании пользователь вводит число, напр (12345), программа его инвертирует (54321)
# Программа использует всего 3 переменных. 
# 'num1' - число - input, которое при каждой итерации сокращается на один разряд, потребность в памяти сокращается (от 40 до 24 байт). 
# 'num2' - переменная, по отношению к num1 обладает обратной механикой (в начале программы занимает 24 байт, в конце - 40)
# 'dig' - буфер, который на каждой итерации содержит integer длиной в 1 символ (32 байт = const)
# Если допустить, что при изменении переменной память будет сразу освобождаться,
# На каждом этапе вычислений переменные будут занимать 96 байт (40 + 24 + 32 или 32 + 32 + 32)
# Cсылок на переменные: 8914 (5799 + 2 + 3113)
# Время выполнения кода порядка 0.33 сек (тест timeit ниже).

""" 
OUTPUT >>>
Инверсия порядка цифр в числе... 12345678901234567890
Выделено памяти под промежуточные изменения num1: 1234567890123456789 <class 'int'> - 40
Выделено памяти под промежуточные изменения num1: 123456789012345678 <class 'int'> - 32
Выделено памяти под промежуточные изменения num1: 12345678901234567 <class 'int'> - 32
Выделено памяти под промежуточные изменения num1: 1234567890123456 <class 'int'> - 32
Выделено памяти под промежуточные изменения num1: 123456789012345 <class 'int'> - 32
Выделено памяти под промежуточные изменения num1: 12345678901234 <class 'int'> - 32
Выделено памяти под промежуточные изменения num1: 1234567890123 <class 'int'> - 32
Выделено памяти под промежуточные изменения num1: 123456789012 <class 'int'> - 32
Выделено памяти под промежуточные изменения num1: 12345678901 <class 'int'> - 32
Выделено памяти под промежуточные изменения num1: 1234567890 <class 'int'> - 32
Выделено памяти под промежуточные изменения num1: 123456789 <class 'int'> - 32
Выделено памяти под промежуточные изменения num1: 12345678 <class 'int'> - 32
Выделено памяти под промежуточные изменения num1: 1234567 <class 'int'> - 32
Выделено памяти под промежуточные изменения num1: 123456 <class 'int'> - 32
Выделено памяти под промежуточные изменения num1: 12345 <class 'int'> - 32
Выделено памяти под промежуточные изменения num1: 1234 <class 'int'> - 32
Выделено памяти под промежуточные изменения num1: 123 <class 'int'> - 32
Выделено памяти под промежуточные изменения num1: 12 <class 'int'> - 32
Выделено памяти под промежуточные изменения num1: 1 <class 'int'> - 32
Выделено памяти под промежуточные изменения num1: 0 <class 'int'> - 24

Результат: 9876543210987654321
Выделено памяти под num1: 0 <class 'int'> - 24
Выделено памяти под num2: 9876543210987654321 <class 'int'> - 40
Выделено памяти под dig: 1 <class 'int'> - 32
"""

# Код программы с флагами

num1 = int(input("Инверсия порядка цифр в числе... "))
num2 = 0
dig = 0

while num1 > 0:
    dig = num1 % 10; # Записываем последнюю цифру числа в буфер
    num1 = num1 // 10; # Исключаем эту цифру из числа
    print(f"Выделено памяти под промежуточные изменения num1: {num1} {type(num1)} - {asizeof.asizeof(num1)}") # Выделено 32 >>> 24 байта
    num2 = num2 * 10 # Увеличиваем разрядность второго числа
    num2 = num2 + dig # Добавляем цифру из буфера

print(f"Результат: {num2}")
print()
print(f"Выделено памяти под num1: {num1} - {asizeof.asizeof(num1)}") # 24
print(f"Выделено памяти под num2: {num2} - {asizeof.asizeof(num2)}") # 40
print(f"Выделено памяти под dig: {dig} - {asizeof.asizeof(dig)}") # 32
print()
print(f"sys.getrefcount(num1) {sys.getrefcount(num1)}") # sys.getrefcount(num1) 5700
print(f"sys.getrefcount(num2) {sys.getrefcount(num2)}") # sys.getrefcount(num2) 2
print(f"sys.getrefcount(dig) {sys.getrefcount(dig)}") # sys.getrefcount(dig) 3114
print()

# timeit тест: 0.3457847091617623
def reverse(num1):
    while num1 > 0:
        num22 = 0
        dig1 = num1 % 10; # Записываем последнюю цифру числа в буфер
        num1 = num1 // 10; # Исключаем эту цифру из числа
        num22 = num22 * 10 # Увеличиваем разрядность второго числа
        num22 = num22 + dig # Добавляем цифру из буфера

t1 = timeit.timeit("reverse(12345678901234567890)", setup="from __main__ import reverse", number=100000) # >>> 0.1074301988555817
print(f"timeit тест: {t1} ")


# In[114]:


# Ниже схожая программа, но она работает с введенным числом, как со строкой, после чего можно конвертировать type в integer.
# В данном коде используется 2 переменных, которые занимают 138 байт на старте программы (56 + 72),
# на пике 144 байт (72 + 72), после реверсии и присвоения строке с результатом type = int 112 (72 + 40) байт 
# Cсылок на переменные: 2794 (2792 + 2)
# Время выполнения кода порядка 0.043 сек (тест timeit ниже).


"""
Выделено памяти под пустую строку rev_str:  - 56 байт
Выделено памяти под строку rev_str: 09876543210987654321 - 72 байт,        после присвоения type = int: - 40 байт 

Результат работы программы: инвертирование числа 12345678901234567890 ...... 9876543210987654321 

sys.getrefcount(rev_str) 2792
sys.getrefcount(aka_input) 2
"""


rev_str = ''
aka_input = input() # '12345678901234567890'
print(f"Выделено памяти под пустую строку rev_str: {rev_str} - {asizeof.asizeof(rev_str)} байт") # 56

def reverse(string):
    rev_str = string[::-1]
    print(f"Выделено памяти под строку rev_str: {rev_str} - {asizeof.asizeof(rev_str)} байт,        после присвоения type = int: - {asizeof.asizeof(int(rev_str))} байт ") # 72 -->  40
    print()
    return int(rev_str)

print(f"Результат работы программы: инвертирование числа {aka_input} ...... {reverse(aka_input)} ") # True
print()
print(f"sys.getrefcount(rev_str) {sys.getrefcount(rev_str)}") # 2792
print(f"sys.getrefcount(aka_input) {sys.getrefcount(aka_input)}") # 2

# timeit тест: 0.04387145133887316
def reverse_2(string):
    rev_str = string[::-1]
    return int(rev_str)

t2 = timeit.timeit("reverse_2('12345678901234567890')", setup="from __main__ import reverse_2", number=100000) # >>> 0.04387145133887316
print(f"timeit тест: {t2} ")


# In[118]:


# Итоги
#
# Переменные в 1 варианте занимают меньше памяти (96 байт против 144 на пике). 
# 2 вариант имеет почти в 3 раза меньше ссылок не переменные (2794 против 8914), быстродействие на порядок выше (0,04 против 0,33).  

